package businessLogics;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardOpenOption;
import java.time.Duration;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Properties;

import javax.mail.BodyPart;
import javax.mail.Folder;
import javax.mail.Message;
import javax.mail.Session;
import javax.mail.Store;
import javax.mail.internet.MimeMultipart;

import com.tyss.optimize.common.util.CommonConstants;
import com.tyss.optimize.nlp.util.Nlp;
import com.tyss.optimize.nlp.util.NlpException;
import com.tyss.optimize.nlp.util.NlpRequestModel;
import com.tyss.optimize.nlp.util.NlpResponseModel;
import com.tyss.optimize.nlp.util.annotation.InputParam;
import com.tyss.optimize.nlp.util.annotation.InputParams;
import com.tyss.optimize.nlp.util.annotation.ReturnType;




public class Fetch_HTML_From_Email implements Nlp {

	@InputParams({ @InputParam(name = "HostName", type = "java.lang.String"),
			@InputParam(name = "Username", type = "java.lang.String"),
			@InputParam(name = "Password", type = "java.lang.String"),
			@InputParam(name = "Email Subject", type = "java.lang.String"),
			@InputParam(name = "Current Time", type = "java.lang.String"),
			@InputParam(name = "Unique String", type = "java.lang.String"),
			@InputParam(name = "Buffer time", type = "java.lang.String") })
	@ReturnType(name = "OTP", type = "java.lang.Integer")

	@Override
	public List<String> getTestParameters() throws NlpException {
		List<String> params = new ArrayList<>();
		return params;
	}

	@Override
	public StringBuilder getTestCode() throws NlpException {
		StringBuilder sb = new StringBuilder();
		return sb;
	}

//	public static Integer flag = 1;

	public NlpResponseModel execute(NlpRequestModel nlpRequestModel) throws NlpException {

		Map<String, Object> programElementsInput = nlpRequestModel.getAttributes();
		String hName = (String) programElementsInput.get("HostName");
		String un = (String) programElementsInput.get("Username");
		String pass = (String) programElementsInput.get("Password");
		String eSub = (String) programElementsInput.get("Email Subject");
		String cTime = (String) programElementsInput.get("Current Time");
		String uniqueString = (String) programElementsInput.get("Unique String");
		String buffTime = (String) programElementsInput.get("Buffer time");
//		Long ctime = (Long) programElementsInput.get("Current time");
		String OneTimeOtp = null;
		NlpResponseModel nlpResponseModel = new NlpResponseModel();
		try {
			OneTimeOtp = getOTPFromMail(hName, un, pass, eSub, cTime, uniqueString, Long.parseLong(buffTime));
			nlpResponseModel.setMessage("Fetched html successfully " + OneTimeOtp);
			nlpResponseModel.setStatus(CommonConstants.pass);
		} catch (Exception e) {
			e.printStackTrace();
			nlpResponseModel.setMessage("Failed to fetch html " + e);
			nlpResponseModel.setStatus(CommonConstants.fail);
		}
		nlpResponseModel.getAttributes().put("OTP", OneTimeOtp);
		return nlpResponseModel;
	}

	public static String getOTPFromMail(String hname, String uname, String pass, String eSub, String cTime,
			String contentInfo, long buffSec) {
		String returnOtp = null;
		Properties properties = new Properties();
		properties.put("mail.store.protocol", "imaps");
		properties.put("mail.imaps.host", hname);
		properties.put("mail.imaps.port", "993");
		properties.put("mail.imaps.ssl.enable", "true");
		try {
			Session session = Session.getInstance(properties);
			Store store = session.getStore("imaps");
			store.connect(hname, uname, pass);
			Folder inbox = store.getFolder("INBOX");
			inbox.open(Folder.READ_ONLY);
			Message[] messages = inbox.getMessages();
			boolean emailFound = false;
			for (int i = messages.length - 1; i >= messages.length - 20; i--) {
				Thread.sleep(2000);
				Message message = messages[i];
				System.out.println(message.getSentDate());
				System.out.println(message.getSubject());
				if (message.getSubject().equalsIgnoreCase(eSub)
						&& getDifference(cTime, message.getSentDate().toString(), buffSec)
						&& getTextFromMessage(message).contains(contentInfo)) {
//	                    System.out.println("Subject: " + message.getSubject());
//	                    System.out.println("Body : " + getTextFromMessage(message));
					emailFound = true;
					returnOtp = createTempHtmlFile(getTextFromMessage(message));
					break;
				}
			}
			if (!emailFound) {
				throw new RuntimeException("No email found with subject: " + eSub);
			}
			inbox.close(false);
			store.close();
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException("Failed to fetch the message " + e.getMessage());
		}
		return returnOtp;
	}

	private static String getTextFromMessage(Message message) throws Exception {
		if (message.isMimeType("text/plain")) {
			return message.getContent().toString();
		} else if (message.isMimeType("text/html")) {
			return message.getContent().toString();
		} else if (message.isMimeType("multipart/*")) {
			MimeMultipart mimeMultipart = (MimeMultipart) message.getContent();
			return getTextFromMimeMultipart(mimeMultipart);
		}
		return "Unsupported content type";
	}

	private static String getTextFromMimeMultipart(MimeMultipart mimeMultipart) throws Exception {
		StringBuilder result = new StringBuilder();
		int count = mimeMultipart.getCount();
		for (int i = 0; i < count; i++) {
			BodyPart bodyPart = mimeMultipart.getBodyPart(i);
			if (bodyPart.isMimeType("text/plain")) {
				result.append(bodyPart.getContent());
			} else if (bodyPart.isMimeType("text/html")) {
				result.append(bodyPart.getContent());
			}
		}
		return result.toString();
	}

	public static String createTempHtmlFile(String htmlContent) {
		try {
			Path tempFile = Files.createTempFile("tempfile_", ".html");
			Files.write(tempFile, htmlContent.getBytes(), StandardOpenOption.WRITE);
			return tempFile.toAbsolutePath().toString();
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}
	}

	private static boolean getDifference(String cTime, String msgTime, long buffSec) {
		LocalDateTime bf = LocalDateTime.parse(cTime, DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"));
		LocalDateTime af = LocalDateTime.parse(
				LocalDateTime.parse(msgTime, DateTimeFormatter.ofPattern("EEE MMM dd HH:mm:ss z yyyy"))
						.format(DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss")),
				DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss"));
		System.out.println(af);
		System.out.println(bf);
		long secondsDiff = Duration.between(bf, af).getSeconds();
		System.out.println(secondsDiff);
		return secondsDiff > 0 && secondsDiff < buffSec;
	}


}